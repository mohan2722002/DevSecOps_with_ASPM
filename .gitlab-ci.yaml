  # GitLab CI/CD Pipeline with Comprehensive Security Scanning
# Project: https://gitlab.com/sahal6282-group/cdac_project

# Global variables
variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  DOCKER_IMAGE_NAME: "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA"
  DOCKER_LATEST_IMAGE: "$CI_REGISTRY_IMAGE:latest"
  SNYK_TOKEN: $SNYK_TOKEN
  SONAR_TOKEN: $SONAR_TOKEN
  SONAR_HOST_URL: $SONAR_HOST_URL
  ZAP_BASELINE_URL: $ZAP_BASELINE_URL
  MAVEN_OPTS: "-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository"
  
# Pipeline stages
stages:
  - validate
  - sast
  - sca
  - secrets
  - build
  - image-scan
  - deploy-test
  - dast
  - compliance
  - deploy

# Global cache configuration
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - .m2/repository/
    - node_modules/
    - .snyk

# Before script for all jobs
before_script:
  - echo "Starting CI/CD Pipeline for commit $CI_COMMIT_SHA"
  - echo "Branch: $CI_COMMIT_REF_NAME"

# ================================
# VALIDATION STAGE
# ================================
validate:
  stage: validate
  image: alpine:latest
  script:
    - echo "Validating pipeline configuration..."
    - echo "Project: $CI_PROJECT_NAME"
    - echo "Registry: $CI_REGISTRY_IMAGE"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ================================
# SAST - STATIC APPLICATION SECURITY TESTING
# ================================
sast-snyk:
  stage: sast
  image: snyk/snyk:node
  variables:
    SNYK_SEVERITY_THRESHOLD: "high"
  before_script:
    - npm install -g snyk
    - snyk auth $SNYK_TOKEN
  script:
    - echo "Running SAST with Snyk..."
    - snyk code test --severity-threshold=$SNYK_SEVERITY_THRESHOLD --json > snyk-sast-report.json || true
    - snyk code test --severity-threshold=$SNYK_SEVERITY_THRESHOLD
  artifacts:
    reports:
      sast: snyk-sast-report.json
    paths:
      - snyk-sast-report.json
    expire_in: 1 week
    when: always
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ================================
# SCA - SOFTWARE COMPOSITION ANALYSIS
# ================================
sca-snyk:
  stage: sca
  image: snyk/snyk:node
  variables:
    SNYK_SEVERITY_THRESHOLD: "high"
  before_script:
    - npm install -g snyk
    - snyk auth $SNYK_TOKEN
  script:
    - echo "Running SCA with Snyk..."
    - |
      if [ -f "package.json" ]; then
        npm install
        snyk test --severity-threshold=$SNYK_SEVERITY_THRESHOLD --json > snyk-sca-report.json || true
        snyk test --severity-threshold=$SNYK_SEVERITY_THRESHOLD
      elif [ -f "pom.xml" ]; then
        snyk test --severity-threshold=$SNYK_SEVERITY_THRESHOLD --json > snyk-sca-report.json || true
        snyk test --severity-threshold=$SNYK_SEVERITY_THRESHOLD
      elif [ -f "requirements.txt" ]; then
        pip install -r requirements.txt
        snyk test --severity-threshold=$SNYK_SEVERITY_THRESHOLD --json > snyk-sca-report.json || true
        snyk test --severity-threshold=$SNYK_SEVERITY_THRESHOLD
      else
        echo "No supported dependency file found"
        exit 1
      fi
  artifacts:
    reports:
      dependency_scanning: snyk-sca-report.json
    paths:
      - snyk-sca-report.json
    expire_in: 1 week
    when: always
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ================================
# SECRETS SCANNING
# ================================
secrets-gitleaks:
  stage: secrets
  image: zricethezav/gitleaks:latest
  script:
    - echo "Scanning for secrets with GitLeaks..."
    - gitleaks detect --source . --report-format json --report-path gitleaks-report.json --verbose
  artifacts:
    reports:
      secret_detection: gitleaks-report.json
    paths:
      - gitleaks-report.json
    expire_in: 1 week
    when: always
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ================================
# BUILD STAGE
# ================================
build-docker-image:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "/certs/client"
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - echo "Building Docker image..."
    - |
      # Create Dockerfile if it doesn't exist (example for Node.js app)
      if [ ! -f "Dockerfile" ]; then
        cat > Dockerfile << EOF
      FROM node:18-alpine AS builder
      WORKDIR /app
      COPY package*.json ./
      RUN npm ci --only=production

      FROM node:18-alpine
      RUN addgroup -g 1001 -S nodejs
      RUN adduser -S nextjs -u 1001
      WORKDIR /app
      COPY --from=builder --chown=nextjs:nodejs /app/node_modules ./node_modules
      COPY --chown=nextjs:nodejs . .
      USER nextjs
      EXPOSE 3000
      CMD ["npm", "start"]
      EOF
      fi
    - docker build --pull -t $DOCKER_IMAGE_NAME .
    - docker tag $DOCKER_IMAGE_NAME $DOCKER_LATEST_IMAGE
    - docker push $DOCKER_IMAGE_NAME
    - docker push $DOCKER_LATEST_IMAGE
    - echo "Docker image built and pushed successfully"
  artifacts:
    reports:
      dotenv: build.env
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ================================
# CONTAINER IMAGE SCANNING
# ================================
image-scan-gitlab:
  stage: image-scan
  image: registry.gitlab.com/security-products/container-scanning:latest
  variables:
    CS_IMAGE: $DOCKER_IMAGE_NAME
    CS_SEVERITY_THRESHOLD: "High"
  script:
    - echo "Scanning Docker image with GitLab Container Scanning..."
  artifacts:
    reports:
      container_scanning: gl-container-scanning-report.json
    paths:
      - gl-container-scanning-report.json
    expire_in: 1 week
    when: always
  dependencies:
    - build-docker-image
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Additional Trivy scan for comprehensive coverage
image-scan-trivy:
  stage: image-scan
  image: aquasec/trivy:latest
  script:
    - echo "Additional scanning with Trivy..."
    - trivy image --format json --output trivy-report.json $DOCKER_IMAGE_NAME
    - trivy image --severity HIGH,CRITICAL --exit-code 1 $DOCKER_IMAGE_NAME
  artifacts:
    paths:
      - trivy-report.json
    expire_in: 1 week
    when: always
  dependencies:
    - build-docker-image
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ================================
# DEPLOY TO TEST ENVIRONMENT
# ================================
deploy-test:
  stage: deploy-test
  image: alpine:latest
  variables:
    DEPLOY_HOST: "test.example.com"
  before_script:
    - apk add --no-cache docker-compose
  script:
    - echo "Deploying to test environment..."
    - |
      cat > docker-compose.test.yml << EOF
      version: '3.8'
      services:
        app:
          image: $DOCKER_IMAGE_NAME
          ports:
            - "3000:3000"
          environment:
            - NODE_ENV=test
          healthcheck:
            test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
            interval: 30s
            timeout: 10s
            retries: 3
      EOF
    - echo "Application deployed to test environment"
    - echo "TEST_URL=http://test.example.com:3000" >> deploy.env
  artifacts:
    reports:
      dotenv: deploy.env
  environment:
    name: test
    url: http://test.example.com:3000
  dependencies:
    - build-docker-image
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ================================
# DAST - DYNAMIC APPLICATION SECURITY TESTING
# ================================
dast-zap:
  stage: dast
  image: owasp/zap2docker-stable:latest
  variables:
    ZAP_TARGET_URL: ${TEST_URL:-http://test.example.com:3000}
  script:
    - echo "Running DAST with OWASP ZAP..."
    - mkdir -p /zap/wrk
    - |
      zap-baseline.py \
        -t $ZAP_TARGET_URL \
        -J zap-baseline-report.json \
        -r zap-baseline-report.html \
        -x zap-baseline-report.xml \
        -w zap-baseline-report.md || true
    - |
      if [ -f "zap-baseline-report.json" ]; then
        echo "ZAP scan completed successfully"
      else
        echo "ZAP scan failed to generate report"
        exit 1
      fi
  artifacts:
    reports:
      dast: zap-baseline-report.json
    paths:
      - zap-baseline-report.json
      - zap-baseline-report.html
      - zap-baseline-report.xml
      - zap-baseline-report.md
    expire_in: 1 week
    when: always
  dependencies:
    - deploy-test
  allow_failure: false
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ================================
# COMPLIANCE SCANNING
# ================================
compliance-sonarqube:
  stage: compliance
  image: sonarqube:community
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
    GIT_DEPTH: "0"
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - echo "Running compliance scanning with SonarQube..."
    - |
      sonar-scanner \
        -Dsonar.projectKey=$CI_PROJECT_NAME \
        -Dsonar.sources=. \
        -Dsonar.host.url=$SONAR_HOST_URL \
        -Dsonar.login=$SONAR_TOKEN \
        -Dsonar.projectVersion=$CI_COMMIT_SHA \
        -Dsonar.scm.revision=$CI_COMMIT_SHA \
        -Dsonar.gitlab.project_id=$CI_PROJECT_ID \
        -Dsonar.gitlab.commit_sha=$CI_COMMIT_SHA \
        -Dsonar.gitlab.ref_name=$CI_COMMIT_REF_NAME \
        -Dsonar.qualitygate.wait=true
  artifacts:
    paths:
      - .sonar/
    expire_in: 1 week
  allow_failure: false
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# ================================
# PRODUCTION DEPLOYMENT
# ================================
deploy-prod:
  stage: deploy
  image: alpine:latest
  variables:
    DEPLOY_HOST: "prod.example.com"
  before_script:
    - apk add --no-cache docker-compose
  script:
    - echo "Deploying to production environment..."
    - |
      cat > docker-compose.prod.yml << EOF
      version: '3.8'
      services:
        app:
          image: $DOCKER_IMAGE_NAME
          ports:
            - "80:3000"
          environment:
            - NODE_ENV=production
          restart: unless-stopped
          healthcheck:
            test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
            interval: 30s
            timeout: 10s
            retries: 3
          deploy:
            replicas: 2
            resources:
              limits:
                cpus: '0.5'
                memory: 512M
      EOF
    - echo "Application deployed to production"
  environment:
    name: production
    url: https://prod.example.com
  when: manual
  only:
    - main
    - master
  dependencies:
    - compliance-sonarqube

# ================================
# SECURITY REPORTING
# ================================
security-report:
  stage: .post
  image: alpine:latest
  script:
    - echo "Generating consolidated security report..."
    - |
      cat > security-summary.md << EOF
      # Security Scan Summary
      
      ## Pipeline: $CI_PIPELINE_ID
      ## Commit: $CI_COMMIT_SHA
      ## Branch: $CI_COMMIT_REF_NAME
      
      ### Scans Performed:
      - âœ… SAST (Snyk Code)
      - âœ… SCA (Snyk Dependencies)  
      - âœ… Secrets (GitLeaks)
      - âœ… Container Image (GitLab + Trivy)
      - âœ… DAST (OWASP ZAP)
      - âœ… Compliance (SonarQube)
      
      ### Artifacts Generated:
      - SAST Report: snyk-sast-report.json
      - SCA Report: snyk-sca-report.json
      - Secrets Report: gitleaks-report.json
      - Container Scan: gl-container-scanning-report.json
      - DAST Report: zap-baseline-report.json
      - Trivy Report: trivy-report.json
      
      Pipeline completed successfully! ðŸŽ‰
      EOF
  artifacts:
    paths:
      - security-summary.md
    expire_in: 30 days
  when: always
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ================================
# NOTIFICATION
# ================================
notify-completion:
  stage: .post
  image: alpine:latest
  script:
    - echo "Pipeline completed for commit $CI_COMMIT_SHA"
    - echo "All security scans passed successfully!"
    - echo "Application is ready for deployment"
  when: on_success
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
